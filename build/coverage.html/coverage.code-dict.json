{"/home/travis/build/npmtest/node-npmtest-ssb-patchwork/test.js":"/* istanbul instrument in package npmtest_ssb_patchwork */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/lib.npmtest_ssb_patchwork.js":"/* istanbul instrument in package npmtest_ssb_patchwork */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_ssb_patchwork = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_ssb_patchwork = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-ssb-patchwork && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_ssb_patchwork */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_ssb_patchwork\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_ssb_patchwork.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_ssb_patchwork.rollup.js'] =\n            local.assetsDict['/assets.npmtest_ssb_patchwork.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_ssb_patchwork.__dirname + '/lib.npmtest_ssb_patchwork.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/index.js":"#! /usr/bin/env node\n\n// load config\nvar path    = require('path')\nvar ssbKeys = require('ssb-keys')\nvar config  = require('ssb-config/inject')(process.env.ssb_appname)\nconfig.keys = ssbKeys.loadOrCreateSync(path.join(config.path, 'secret'))\nif(config.keys.curve === 'k256')\n  throw new Error('k256 curves are no longer supported,'+\n                  'please delete' + path.join(config.path, 'secret'))\n\n\n// run electron-specific code, if appropriate\nif (process.versions['electron']) {\n  require('./electron')(config)\n} else {\n  require('./server-process')(config)\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/config.js":"var fs = require('fs')\nmodule.exports = function (conf) {\n  // ask the oracle thy question\n  var oracle = {\n    getHostname: function () {\n      return conf.host || 'localhost'\n    },\n    getPort: function () {\n      return 7777\n    },\n    getLocalUrl: function () {\n      return (oracle.useTLS()?'https':'http')+'://'+oracle.getHostname()+':'+oracle.getPort()\n    },\n\n    allowRemoteAccess: function () {\n      return conf.allowRemoteAccess\n    },\n\n    requiresPassword: function () {\n      return isString(conf.singleUserPassword)\n    },\n    checkPassword: function (str) {\n      return str === conf.singleUserPassword\n    },\n\n    useTLS: function () {\n      return !!conf.tls\n    },\n    validateTLS: function () {\n      if (!isObject(conf.tls)) {\n        console.log('ERROR! tls config requires tls.key (path to the keyfile) and tls.cert (path to the certfile)')\n        return false\n      }\n      if (!isString(conf.tls.key)) {\n        console.log('ERROR! tls.key, a path to your TLS key, is required for TLS to work.')\n        return false\n      }\n      if (!isString(conf.tls.cert)) {\n        console.log('ERROR! tls.cert, a path to your TLS cert, is required for TLS to work.')\n        return false\n      }\n      try {\n        var keyStat = fs.statSync(conf.tls.key)\n        if (!keyStat.isFile())\n          throw \"err\"\n      } catch (e) {\n        console.log('ERROR! the file specified by the tls.key path was not valid.')\n        return false\n      }\n      try {\n        var certStat = fs.statSync(conf.tls.cert)\n        if (!certStat.isFile())\n          throw \"err\"\n      } catch (e) {\n        console.log('ERROR! the file specified by the tls.cert path was not valid.')\n        return false\n      }\n      return true\n    },\n    getTLS: function () {\n      return {\n        key: fs.readFileSync(conf.tls.key),\n        cert: fs.readFileSync(conf.tls.cert)\n      }\n    },\n\n    // function to validate the config choices made\n    hasError: function () {\n      // error: allowing remote access but without a TLS cert\n      if (this.allowRemoteAccess() && !this.useTLS())\n        return true\n      // error: bad TLS config\n      if (this.useTLS() && !this.validateTLS())\n        return true\n    },\n    allowUnsafe: function () {\n      return conf.unsafe\n    }\n  }\n\n  // give the user some feedback about the config state\n\n  // password config\n  if (oracle.requiresPassword())\n    console.log('[CFG] Password: YES.')\n  else\n    console.log('[CFG] Password: NO.')\n\n  // TLS\n  if (oracle.useTLS())\n    console.log('[CFG] TLS: YES.')\n  else\n    console.log('[CFG] TLS: NO.')\n\n  // allowRemoteAccess variations\n  if (oracle.allowRemoteAccess()) {\n    console.log('[CFG] Remote Access: YES.')\n    if (!oracle.requiresPassword())\n      console.log('WARNING! Remote access is allowed, but no password is configured. This is not safe!')\n    if (!oracle.useTLS())\n      console.log('ERROR! Remote access is allowed, but no TLS security is configured. Other devices will be able to steal the password or inject attacks.')\n  } else\n    console.log('[CFG] Remote Access: NO.')\n\n  return oracle\n}\n\nfunction isString (v) {\n  return v && typeof v == 'string'\n}\nfunction isObject (v) {\n  return v && typeof v == 'object'\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/http-server.js":"var pull   = require('pull-stream')\nvar toPull = require('stream-to-pull-stream')\nvar cat    = require('pull-cat')\nvar ident  = require('pull-identify-filetype')\nvar mime   = require('mime-types')\nvar URL    = require('url')\nvar path   = require('path')\nvar fs     = require('fs')\nvar refs   = require('ssb-ref')\nvar Stack  = require('stack')\nvar ip     = require('ip')\n\nvar AppCSP = function (req, config) {\n  // hostname for the websocket connection:\n  // if it's a remote request, always use the configured hostname\n  // if it's local, choose from localhost or the configured hostname, based on which the client is using (as revealed by the host header)\n  var host\n  if (!ip.isLoopback(req.socket.remoteAddress))\n    host = config.getHostname()\n  else {\n    var requestHostname = req.headers.host.split(':')[0] // extract hostname (remove ':port')\n    host = (requestHostname == 'localhost' || requestHostname == config.getHostname())\n      ? requestHostname\n      : (config.getHostname() || 'localhost')\n\n    // final glorious hack: if they're using 127.0.0.1, we should too\n    if (requestHostname == '127.0.0.1' && host == 'localhost')\n      host = '127.0.0.1'\n  }\n\n  return \"default-src 'self'; \"+\n    \"connect-src 'self' ws://\"+host+\":7777 wss://\"+host+\":7777; \"+\n    \"img-src 'self' data:; \"+\n    \"object-src 'none'; \"+\n    \"frame-src 'none'; \"+\n    \"style-src 'self' 'unsafe-inline'; \"+\n    \"sandbox allow-modals allow-same-origin allow-scripts allow-top-navigation allow-popups\"\n}\nvar BlobCSP = function () { return \"default-src none; sandbox\" }\n\nfunction respond (res, status, message) {\n  res.writeHead(status)\n  res.end(message)\n}\n\nfunction respondSource (res, source, wrap) {\n  if(wrap) {\n    res.writeHead(200, {'Content-Type': 'text/html'})\n    pull(\n      cat([\n        pull.once('<html><body><script>'),\n        source,\n        pull.once('</script></body></html>')\n      ]),\n      toPull.sink(res)\n    )\n  }\n  else {\n    pull(\n      source,\n      ident(function (type) {\n        if (type) res.writeHead(200, {'Content-Type': mime.lookup(type)})\n      }),\n      toPull.sink(res)\n    )\n  }\n}\n\nvar Log = exports.Log = function (sbot) {\n  return function (req, res, next) {\n    sbot.emit('log:info', ['HTTP', null, req.method + ' ' + req.url])\n    next()\n  }\n}\n\nvar DeviceAccessControl = exports.DeviceAccessControl = function (config) {\n  return function (req, res, next) {\n    if (config.allowRemoteAccess())\n      return next() // remote & local access allowed\n    if (ip.isLoopback(req.socket.remoteAddress))\n      return next() // local access allowed\n    respond(res, 403, 'Remote access forbidden') // remote access disallowed\n  }\n}\n\nvar PasswordAccessControl = exports.DeviceAccessControl = function (config) {\n  return function (req, res, next) {\n    if (!config.requiresPassword(config))\n      return next() // no password required\n\n    // check the password\n    var authMatch = /^Basic (.*)$/i.exec(req.headers.authorization)\n    if (authMatch) {\n      var password = (new Buffer(authMatch[1], 'base64').toString()).split(':')[1]\n      if (password && config.checkPassword(password))\n        return next() // password checks out\n    }\n\n    // deny\n    res.setHeader('WWW-Authenticate', 'Basic realm=Authorization Required')\n    respond(res, 401, 'Unauthorized')\n  }\n}\n\nvar ServeApp = exports.ServeApp = function (sbot, opts, config) {\n  if (!opts || !opts.uiPath)\n    throw \"opts.uiPath is required\"\n  return function (req, res, next) {\n    var parsed = URL.parse(req.url, true)\n    var pathname = parsed.pathname\n    if (pathname == '/')\n      pathname = '/main.html'\n\n    // dynamic route: manifest.js\n    if (pathname == '/manifest.js') {\n      res.setHeader('Content-Security-Policy', BlobCSP())\n      return respondSource(res, pull.once('window.MANIFEST='+JSON.stringify(sbot.manifest())+';'))\n    } \n\n    // static files\n    var filepath = path.join(opts.uiPath, pathname)\n    fs.stat(filepath, function (err, stat) {\n      if(err) return next()\n      if(!stat.isFile()) return respond(res, 403, 'May only load files')\n\n      // set a special CSP for the main HTML file\n      if (pathname == '/main.html')\n        res.setHeader('Content-Security-Policy', AppCSP(req, config)) // only give the open perms to main.html\n      else\n        res.setHeader('Content-Security-Policy', BlobCSP())\n\n      respondSource(res, toPull.source(fs.createReadStream(filepath)))\n    })\n  }\n}\n\nvar ServeBlobs = exports.ServeBlobs = function (sbot) {\n  return function (req, res, next) {\n    var parsed = URL.parse(req.url, true)\n    var hash = decodeURIComponent(parsed.pathname.slice(1))\n    sbot.blobs.want(hash, function(err, has) {\n      if (!has) return respond(res, 404, 'File not found')\n\n      // optional name override\n      if (parsed.query.name)\n        res.setHeader('Content-Disposition', 'inline; filename='+encodeURIComponent(parsed.query.name))\n\n      // serve\n      res.setHeader('Content-Security-Policy', BlobCSP())\n      respondSource(res, sbot.blobs.get(hash), false)\n    })\n  }\n}\n\nvar ServeFiles = exports.ServeFiles = function () {\n  return function (req, res, next) {\n    var parsed = URL.parse(req.url, true)\n    fs.stat(parsed.pathname, function (err, stat) {\n      if(err) return respond(res, 404, 'File not found')\n      if(!stat.isFile()) return respond(res, 403, 'May only load files')\n      res.setHeader('Content-Security-Policy', BlobCSP())\n      respondSource(\n        res,\n        toPull.source(fs.createReadStream(parsed.pathname)),\n        false\n      )\n    })\n  }\n}\n\nexports.BlobStack = function (sbot, opts) {\n  return Stack(\n    Log(sbot),\n    DeviceAccessControl(),\n    ServeBlobs(sbot)\n  )\n}\n\nexports.FileStack = function (opts) {\n  return Stack(\n    Log(sbot),\n    DeviceAccessControl(),\n    ServeFiles()\n  )\n}\n\nexports.AppStack = function (sbot, opts, config) {\n  return Stack(\n    Log(sbot),\n    PasswordAccessControl(config),\n    DeviceAccessControl(config),\n    ServeApp(sbot, opts, config),\n    ServeBlobs(sbot)\n  )\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/server-process.js":"var path    = require('path')\nvar ssbKeys = require('ssb-keys')\n\nmodule.exports = function (config, cb) {\n  // load config\n\n  // load languages\n  var t = require('patchwork-translations')\n  t.setLocale(require('os-locale').sync())\n\n  // validate the config\n  var configOracle = require('./config')(config)\n  if (configOracle.hasError()) {\n    if (configOracle.allowUnsafe())\n      console.log('\\n' + t('unsafeConfigIgnore'))\n    else {\n      console.log('\\n' + t('unsafeConfigAbort'))\n      return\n    }\n  }\n\n  logLicense() // per the GPL's recommendation, let ppl know the license\n\n  console.log(t('Starting'))\n\n  // start sbot\n  var createSbot = require('scuttlebot')\n    .use(require('scuttlebot/plugins/master'))\n    .use(require('./lib/persistent-gossip')) // override\n    .use(require('./lib/friends-with-gossip-priority'))\n    .use(require('scuttlebot/plugins/replicate'))\n    .use(require('ssb-blobs'))\n    .use(require('scuttlebot/plugins/invite'))\n    .use(require('scuttlebot/plugins/block'))\n    .use(require('scuttlebot/plugins/logging'))\n    .use(require('scuttlebot/plugins/private'))\n    .use(require('scuttlebot/plugins/local'))\n    .use(require('ssb-notifier'))\n    .use(require('./api'))\n\n  var sbot = createSbot(config)\n\n  // write manifest file\n  var fs = require('fs')\n  fs.writeFileSync(\n    path.join(config.path, 'manifest.json'),\n    JSON.stringify(sbot.getManifest(), null, 2)\n  )\n\n  // setup server\n  var http = require('http')\n  var https = require('https')\n  var ws = require('pull-ws-server')\n  var httpStack = require('./http-server')\n  var httpServerFn = httpStack.AppStack(sbot, { uiPath: path.join(__dirname, 'ui') }, configOracle)\n  var wsServerFn = require('./ws-server')(sbot)\n\n  var serverOpts = configOracle.useTLS() ? configOracle.getTLS() : {}\n  serverOpts.verifyClient = require('./ws-server').verifyClient(configOracle)\n  var server = ws.createServer(serverOpts)\n  server.on('error', fatalError)\n  server.on('connection', wsServerFn)\n  server.on('request', httpServerFn)\n  server.listen(configOracle.getPort())\n  if (cb) {\n    server.once('listening', cb)\n  }\n  console.log(t('ServingAt', {url: configOracle.getLocalUrl()}))\n\n  // basic error handling\n  function fatalError (e) {\n    if (e.code === 'EADDRINUSE')\n      console.error('\\n' + t('PortInUse', {port: e.port}) + '\\n')\n    else\n      console.error(e.stack || e.toString())\n    process.exit(1)\n  }\n  process.on('uncaughtException', fatalError)\n\n  function logLicense () {\n    console.log(t('LicenseConsole', {years: '2015-2016'}) + '\\n')\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ws-server.js":"var muxrpc = require('muxrpc')\nvar pull = require('pull-stream')\nvar Serializer = require('pull-serializer')\n\nmodule.exports = function (sbot, opts) {\n  return function (stream) {\n    // create rpc object\n    var rpc = muxrpc({}, sbot.manifest(), serialize)(sbot)\n    rpc.authorized = { id: sbot.id, role: 'master' }\n\n    // start the stream\n    pull(stream, rpc.createStream(), stream)\n  }\n}\n\nfunction serialize (stream) {\n  return Serializer(stream, JSON, {split: '\\n\\n'})\n}\n\nmodule.exports.verifyClient = function (config) {\n  return function (info) {\n    return info.origin === config.getLocalUrl()\n  }\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/api/index.js":"var fs          = require('fs')\nvar pull        = require('pull-stream')\nvar multicb     = require('multicb')\nvar pl          = require('pull-level')\nvar pushable    = require('pull-pushable')\nvar paramap     = require('pull-paramap')\nvar cat         = require('pull-cat')\nvar Notify      = require('pull-notify')\nvar toPull      = require('stream-to-pull-stream')\nvar ref         = require('ssb-ref')\nvar pathlib     = require('path')\nvar mlib        = require('ssb-msgs')\nvar threadlib   = require('patchwork-threads')\nvar u           = require('./util')\n\nexports.name        = 'patchwork'\nexports.version     = '1.0.0'\nexports.manifest    = require('./manifest')\nexports.permissions = require('./permissions')\n\nexports.init = function (sbot, opts) {\n\n  var api = {}\n  var patchworkdb = sbot.sublevel('patchwork')\n  var db = {\n    isread: patchworkdb.sublevel('isread'),\n    bookmarked: patchworkdb.sublevel('bookmarked'),\n    channelpinned: patchworkdb.sublevel('channelpinned'),\n    channelwatched: patchworkdb.sublevel('channelwatched')\n  }\n  var state = {\n    // indexes (lists of {key:, ts:})\n    mymsgs: [],\n    inbox: u.index('inbox'),\n    bookmarks: u.index('bookmarks'),\n    mentions: u.index('mentions'),\n    notices: u.index('notices'),\n    privatePosts: u.index('privatePosts'),\n    publicPosts: u.index('publicPosts'),\n    // other indexes: channel-* are created as needed\n\n    // views\n    profiles: {},\n    names: {}, // ids -> names\n    ids: {}, // names -> ids\n    actionItems: {}\n  }\n\n  // track sync state\n  // - processor does async processing for each message that comes in\n  // - awaitSync() waits for that processing to finish\n  // - pinc() on message arrival, pdec() on message processed\n  // - nP === 0 => all messages processed\n  var nP = 0, syncCbs = []\n  function awaitSync (cb) {\n    if (nP > 0)\n      syncCbs.push(cb)\n    else cb()\n  }\n  state.pinc = function () { nP++ }\n  state.pdec = function () {\n    nP--\n    if (nP === 0) {\n      syncCbs.forEach(function (cb) { cb() })\n      syncCbs.length = 0\n    }\n  }\n\n  // load bookmarks into indexes\n  pull(\n    pl.read(db.bookmarked, { keys: true, values: false }),\n    pull.asyncMap(function (key, cb) {\n      // fetch the message and isread data\n      var obj = { key: key, value: null, isread: false }\n      db.isread.get(key, function (err, isread) { obj.isread = isread; done() })\n      sbot.get(key, function (err, value) { obj.value = value; done() })\n      var n=0;\n      function done() {\n        if (++n == 2) cb(null, obj)\n      }\n    }),\n    pull.drain(\n      function (msg) {\n        if (msg.value) {\n          // add to the inbox index\n          row = state.inbox.sortedUpsert(msg.value.timestamp, msg.key)\n          row.isread = msg.isread\n\n          // add to the bookmarks index, only if the wont already be in the private msgs index\n          if (msg.value && typeof msg.value.content != 'string') {\n            var row = state.bookmarks.sortedUpsert(msg.value.timestamp, msg.key)\n            row.isread = msg.isread\n          }\n        }\n      }\n    )\n  )\n\n  // load channelpins into indexes\n  pull(\n    pl.read(db.channelpinned, { keys: true, values: true }),\n    pull.drain(function (pin) {\n      if (typeof pin.key === 'string') {\n        var index = getChannelIndex(pin.key)\n        index.pinned = pin.value\n      }\n    })\n  )\n\n  // load channelwatches into indexes\n  state.pinc()\n  pull(\n    pl.read(db.channelwatched, { keys: true, values: true }),\n    pull.drain(function (watch) {\n      if (typeof watch.key === 'string') {\n        var index = getChannelIndex(watch.key)\n        index.watched = watch.value\n      }\n    },\n    function () { state.pdec() })\n  )\n\n  // setup sbot log processor\n  var isHistorySynced = false // track so we dont emit events for old messages\n  var processor = require('./processor')(sbot, db, state, emit)\n  awaitSync(function () { // wait for channelwatches to load up\n    // create log stream\n    pull(pl.read(sbot.sublevel('log'), { live: true, onSync: onHistorySync }), pull.drain(processor))\n    state.pinc()\n    function onHistorySync () {\n      console.log('Log history read...')\n      // when all current items finish, consider prehistory synced (and start emitting)\n      awaitSync(function () { \n        console.log('Indexes generated')\n        isHistorySynced = true\n      })\n      state.pdec()\n    }\n  })\n\n  // events stream\n  var notify = Notify()\n  function emit (type, data) {\n    if (!isHistorySynced)\n      return\n    var e = data || {}\n    e.type = type\n    if (e.type == 'index-change') {\n      api.getIndexCounts(function (err, counts) {\n        e.counts = counts\n        e.total = counts[e.index]\n        e.unread = counts[e.index+'Unread']\n        notify(e)\n      })\n    } else\n      notify(e)\n  }\n\n  // getters\n\n  api.createEventStream = function () {\n    return notify.listen()\n  }\n\n  api.getMyProfile = function (cb) {\n    awaitSync(function () {\n      api.getProfile(sbot.id, cb)\n    })\n  }\n\n  api.getIndexCounts = function (cb) {\n    awaitSync(function () {\n      var counts = {\n        inboxUnread: state.inbox.filter(function (row) { return !row.isread }).length,\n        bookmarkUnread: state.bookmarks.filter(function (row) { return !row.isread }).length,\n        mentionUnread: state.mentions.filter(function (row) { return !row.isread }).length,\n        privateUnread: state.privatePosts.filter(function (row) { return !row.isread }).length,\n        noticesUnread: state.notices.countUntouched()\n      }\n      cb(null, counts)\n    })\n  }\n\n  api.createInboxStream = indexStreamFn(state.inbox)\n  api.createBookmarkStream = indexStreamFn(state.bookmarks)\n  api.createMentionStream = indexStreamFn(state.mentions)\n  api.createNoticeStream = indexStreamFn(state.notices)\n  api.createPrivatePostStream = indexStreamFn(state.privatePosts)\n  api.createPublicPostStream = indexStreamFn(state.publicPosts)\n  api.createChannelStream = function (channel, opts) {\n    if (typeof channel !== 'string' || !channel.trim())\n      return cb(new Error('Invalid channel'))\n    var index = getChannelIndex(channel)\n    return indexStreamFn(index)(opts)\n  }\n  api.createSearchStream = function (opts) {\n    opts = opts || {}\n    var searchRegex = new RegExp(opts.query||'', 'i')\n    \n    var limit = opts.limit\n    delete opts.limit\n\n    opts.type = 'post'\n    return pull(\n      sbot.messagesByType(opts),\n      pull.asyncMap(function (msg, cb) {\n        // decrypt the message, if needed\n        threadlib.decryptThread(sbot, msg, cb)\n      }),\n      pull.filter(function (msg) {\n        // run search filter\n        return searchRegex.test(''+msg.value.content.text)\n      }),\n      limit ? pull.take(limit) : undefined\n    )\n  }\n\n  function indexMarkRead (indexname, key, keyname) {\n    if (Array.isArray(key)) {\n      key.forEach(function (k) {\n        indexMarkRead(indexname, k, keyname)\n      })\n      return\n    }\n\n    var index = state[indexname]\n    var row = index.find(key, keyname)\n    if (row) {\n      var wasread = row.isread\n      row.isread = true\n      if (!wasread)\n        emit('index-change', { index: indexname })\n      return true\n    }\n  }\n\n  function indexMarkUnread (indexname, key, keyname) {\n    if (Array.isArray(key)) {\n      key.forEach(function (k) {\n        indexMarkUnread(indexname, k, keyname)\n      })\n      return\n    }\n\n    var index = state[indexname]\n    var row = index.find(key, keyname)\n    if (row) {\n      var wasread = row.isread\n      row.isread = false\n      if (wasread)\n        emit('index-change', { index: indexname })\n      return true\n    }\n  }\n\n  api.markRead = function (key, cb) {\n    awaitSync(function () {\n      indexMarkRead('inbox', key)\n      indexMarkRead('bookmarks', key)\n      indexMarkRead('mentions', key)\n      indexMarkRead('privatePosts', key)\n      if (Array.isArray(key)) {\n        db.isread.batch(key.map(function (k) { return { type: 'put', key: k, value: 1 }}), cb)\n        key.forEach(function (key) { emit('isread', { key: key, value: true }) })\n      } else {\n        db.isread.put(key, 1, cb)\n        emit('isread', { key: key, value: true })\n      }\n    })\n  }\n  api.markUnread = function (key, cb) {\n    awaitSync(function () {\n      indexMarkUnread('inbox', key)\n      indexMarkUnread('bookmarks', key)\n      indexMarkUnread('mentions', key)\n      indexMarkUnread('privatePosts', key)\n      if (Array.isArray(key)) {\n        db.isread.batch(key.map(function (k) { return { type: 'del', key: k }}), cb)\n        key.forEach(function (key) { emit('isread', { key: key, value: false }) })\n      } else {\n        db.isread.del(key, cb) \n        emit('isread', { key: key, value: false })\n      }\n    })\n  }\n  api.markAllRead = function (indexName, cb) {\n    awaitSync(function () {\n      var index = state[indexName]\n      if (!index || index.name !== indexName)\n        return cb(new Error('Invalid index'))\n\n      var done = multicb()\n      index\n        .filter(function (row) { return !row.isread })\n        .forEach(function (row) { \n          var cb = done()\n          threadlib.getPostThread(sbot, row.key, { isRead: true }, function (err, thread) {\n            if (err)\n              return cb()\n            threadlib.markThreadRead(sbot, thread, cb)\n          })\n        })\n      done(cb)\n    })\n  }\n  api.toggleRead = function (key, cb) {\n    api.isRead(key, function (err, v) {\n      if (!v) {\n        api.markRead(key, function (err) {\n          cb(err, true)\n        })\n      } else {\n        api.markUnread(key, function (err) {\n          cb(err, false)\n        })\n      }\n    })\n  }\n  api.isRead = function (key, cb) {\n    if (Array.isArray(key)) {\n      var done = multicb({ pluck: 1 })\n      key.forEach(function (k, i) {\n        var cb = done()\n        db.isread.get(k, function (err, v) { cb(null, !!v) })\n      })\n      done(cb)\n    } else {\n      db.isread.get(key, function (err, v) {\n        cb && cb(null, !!v)\n      })\n    }\n  }\n \n  api.bookmark = function (key, cb) {\n    sbot.get(key, function (err, value) {\n      if (err) return cb(err)\n      var done = multicb({ pluck: 1, spread: true })\n      db.bookmarked.put(key, 1, done()) // update bookmarks index\n      u.getThreadHasUnread(sbot, key, done()) // get the target thread's read/unread state\n      done(function (err, putRes, hasUnread) {\n        // insert into the bookmarks and inbox indexes\n        var bookmarksRow = state.bookmarks.sortedUpsert(value.timestamp, key)\n        bookmarksRow.isread = !hasUnread // set isread state\n        emit('index-change', { index: 'bookmarks' })\n        var inboxRow = state.inbox.sortedUpsert(value.timestamp, key)\n        inboxRow.isread = !hasUnread // set isread state\n        emit('index-change', { index: 'inbox' })\n        cb(err, putRes)\n      })\n    })\n  }\n  api.unbookmark = function (key, cb) {\n    sbot.get(key, function (err, value) {\n      if (err) return cb(err)\n      state.bookmarks.remove(key)\n      state.inbox.remove(key)\n      db.bookmarked.del(key, cb) \n    })\n  }\n  api.toggleBookmark = function (key, cb) {\n    api.isBookmarked(key, function (err, v) {\n      if (!v) {\n        api.bookmark(key, function (err) {\n          cb(err, true)\n        })\n      } else {\n        api.unbookmark(key, function (err) {\n          cb(err, false)\n        })\n      }\n    })\n  }\n  api.isBookmarked = function (key, cb) {\n    db.bookmarked.get(key, function (err, v) {\n      cb && cb(null, !!v)\n    })\n  }\n\n  function getChannelIndex (channel) {\n    var k = 'channel-'+channel\n    var index = state[k]\n    if (!index)\n      index = state[k] = u.index(k)\n    return index\n  }\n  api.getChannels = function (cb) {\n    awaitSync(function () {\n      var channels = []\n      for (var k in state) {\n        if (k.indexOf('channel-') === 0) {\n          var lastUpdated = (state[k].rows[0]) ? state[k].rows[0].ts : 0\n          channels.push({\n            name: k.slice('channel-'.length),\n            lastUpdated: lastUpdated,\n            pinned: state[k].pinned,\n            watched: state[k].watched\n          })\n        }\n      }\n      cb(null, channels)\n    })\n  }\n  api.pinChannel = function (channel, cb) {\n    var index = getChannelIndex(channel)\n    index.pinned = true\n    db.channelpinned.put(channel, 1, cb)\n    emit('channelpinned', { channel: channel, value: true })\n  }\n  api.unpinChannel = function (channel, cb) {\n    var index = getChannelIndex(channel)\n    index.pinned = false\n    db.channelpinned.del(channel, cb) \n    emit('channelpinned', { channel: channel, value: false })\n  }\n  api.toggleChannelPinned = function (channel, cb) {\n    var index = getChannelIndex(channel)\n    if (index.pinned) {\n      api.unpinChannel(channel, function (err) {\n        cb(err, true)\n      })\n    } else {\n      api.pinChannel(channel, function (err) {\n        cb(err, false)\n      })\n    }\n  }\n  api.watchChannel = function (channel, cb) {\n    var index = getChannelIndex(channel)\n    index.watched = true\n    db.channelwatched.put(channel, 1, cb)\n    emit('channelwatched', { channel: channel, value: true })\n  }\n  api.unwatchChannel = function (channel, cb) {\n    var index = getChannelIndex(channel)\n    index.watched = false\n    db.channelwatched.del(channel, cb) \n    emit('channelwatched', { channel: channel, value: false })\n  }\n  api.toggleChannelWatched = function (channel, cb) {\n    var index = getChannelIndex(channel)\n    if (index.watched) {\n      api.unwatchChannel(channel, function (err) {\n        cb(err, true)\n      })\n    } else {\n      api.watchChannel(channel, function (err) {\n        cb(err, false)\n      })\n    }\n  }\n\n  api.addFileToBlobs = function (base64Buff, cb) {\n    return pull(\n      pull.values([new Buffer(base64Buff, 'base64')]),\n      sbot.blobs.add(cb)\n    )\n  }\n  api.saveBlobToFile = function (hash, path, cb) {\n    pull(\n      sbot.blobs.get(hash),\n      toPull.sink(fs.createWriteStream(path), cb)\n    )\n  }\n\n  var lookupcodeRegex = /(@[a-z0-9\\/\\+\\=]+\\.[a-z0-9]+)(?:\\[via\\])?(.+)?/i\n  api.useLookupCode = function (code) {\n    var eventPush = pushable()\n\n    // parse and validate the code\n    var id, addrs\n    var parts = lookupcodeRegex.exec(code)\n    var valid = true\n    if (parts) {\n      id  = parts[1]\n      addrs = (parts[2]) ? parts[2].split(',') : []\n\n      // validate id\n      if (!ref.isFeedId(id))\n        valid = false\n\n      // parse addresses\n      addrs = addrs\n        .map(function (addr) {\n          addr = addr.split(':')\n          if (addr.length === 3)\n            return { host: addr[0], port: +addr[1], key: addr[2] }\n        })\n        .filter(Boolean)\n    } else\n      valid = false\n\n    if (!valid) {\n      eventPush.push({ type: 'error', message: 'Invalid lookup code' })\n      eventPush.end()\n      return eventPush\n    }\n\n    // begin the search!\n    search(addrs.concat(sbot.gossip.peers()))\n    function search (peers) {\n      var peer = peers.pop()\n      if (!peer)\n        return eventPush.end()\n\n      // connect to the peer\n      eventPush.push({ type: 'connecting', addr: peer })      \n      sbot.connect(peer, function (err, rpc) {\n        if (err) {\n          eventPush.push({ type: 'error', message: 'Failed to connect', err: err })\n          return search(peers)\n        }\n        // try a sync\n        sync(rpc, function (err, seq) { \n          if (seq > 0) {\n            // success!\n            eventPush.push({ type: 'finished', seq: seq })\n            eventPush.end()\n          } else\n            search(peers) // try next\n        })\n      })\n    }\n\n    function sync (rpc, cb) {\n      // fetch the feed\n      var seq\n      eventPush.push({ type: 'syncing', id: id })\n      pull(\n        rpc.createHistoryStream({ id: id, keys: false }),\n        pull.through(function (msg) {\n          seq = msg.sequence\n        }),\n        sbot.createWriteStream(function (err) {\n          cb(err, seq)\n        })\n      )\n    }\n\n    return eventPush\n  }\n\n  api.getProfile = function (id, cb) {\n    awaitSync(function () { cb(null, state.profiles[id]) })\n  }\n  api.getAllProfiles = function (cb) {\n    awaitSync(function () { cb(null, state.profiles) })\n  }\n  api.getNamesById = function (cb) {\n    awaitSync(function () { cb(null, state.names) })\n  }\n  api.getIdsByName = function (cb) {\n    awaitSync(function () { cb(null, state.ids) })\n  }\n  api.getName = function (id, cb) {\n    awaitSync(function () { cb(null, state.names[id]) })\n  }\n  api.getActionItems = function (cb) {\n    awaitSync(function () { cb(null, state.actionItems) })\n  }\n\n  // helper to get an option off an opt function (avoids the `opt || {}` pattern)\n  function o (opts, k, def) {\n    return opts && opts[k] !== void 0 ? opts[k] : def\n  }\n\n  // helper to get messages from an index\n  function indexStreamFn (index, getkey) {\n    return function (opts) {\n      var lastAccessed = index.lastAccessed\n      index.touch()\n\n      // emulate the `ssb.createFeedStream` interface\n      var lt      = o(opts, 'lt')\n      var lte     = o(opts, 'lte')\n      var gt      = o(opts, 'gt')\n      var gte     = o(opts, 'gte')\n      var limit   = o(opts, 'limit')\n      var threads = o(opts, 'threads')\n      var unread  = o(opts, 'unread')\n\n      // lt, lte, gt, gte should look like:\n      // [msg.value.timestamp, msg.value.author]\n\n      // helper to create emittable rows\n      function lookup (row) {\n        if (!row) return\n        var key = (getkey) ? getkey(row) : row.key\n        if (key) {\n          var rowcopy = { key: key }\n          for (var k in row) { // copy index attrs into rowcopy\n            if (!rowcopy[k]) rowcopy[k] = row[k]\n          }\n          return rowcopy\n        }\n      }\n\n      // helper to fetch rows\n      function fetch (row, cb) {\n        if (threads) {\n          threadlib.getPostSummary(sbot, row.key, { isBookmarked: true, isRead: true, votes: true, mentions: sbot.id }, function (err, thread) {\n            for (var k in thread)\n              row[k] = thread[k]\n            cb(null, row)\n          })\n        } else {\n          sbot.get(row.key, function (err, value) {\n            // if (err) {\n              // suppress this error\n              // the message isnt in the local cache (yet)\n              // but it got into the index, likely due to a link\n              // instead of an error, we'll put a null there to indicate the gap\n            // }\n            row.value = value\n            cb(null, row)\n          })\n        }\n      }\n\n      // readstream\n      var readPush = pushable()\n      var read = pull(readPush, paramap(fetch))\n\n      // await sync, then emit the reads\n      awaitSync(function () {\n        var added = 0\n        for (var i=0; i < index.rows.length; i++) {\n          var row = index.rows[i]\n\n          if (limit && added >= limit)\n            break\n\n          // we're going to only look at timestamp, because that's all that the index tracks\n          var invalid = !!(\n            (lt  && row.ts >= lt[0]) ||\n            (lte && row.ts > lte[0]) ||\n            (gt  && row.ts <= gt[0]) ||\n            (gte && row.ts < gte[0]) ||\n            (unread && row.isread)\n          )\n          if (invalid)\n            continue\n\n          var r = lookup(row)\n          if (r) {\n            r.isNew = r.ts > lastAccessed\n            readPush.push(r)\n            added++\n          }\n        }\n        readPush.end()\n      })\n\n      if (opts && opts.live) {\n        // live stream, concat the live-emitter on the end\n        index.on('add', onadd)\n        var livePush = pushable(function () { index.removeListener('add', onadd) })\n        function onadd (row) { livePush.push(lookup(row)) }\n        var live = pull(livePush, paramap(fetch))\n        return cat([read, live])\n      }\n      return read\n    }\n  }\n\n  return api\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/api/util.js":"var mlib = require('ssb-msgs')\nvar multicb = require('multicb')\nvar EventEmitter = require('events').EventEmitter\nvar threadlib = require('patchwork-threads')\n\n// constant used to decide if an index-entry was recent enough to emit an 'add' event for\nvar IS_RECENT_MAX = 1e3 * 60 * 60 * 48 // 2 days\n\nmodule.exports.index = function (name) {\n  var index = new EventEmitter()\n  index.name = name\n  index.rows = []\n  index.lastAccessed = Date.now()\n\n  index.touch = function () {\n    index.lastAccessed = Date.now()\n  }\n\n  index.sortedInsert = function (ts, key) {\n    var row = (typeof ts == 'object') ? ts : { ts: ts, key: key }\n    for (var i=0; i < index.rows.length; i++) {\n      if (index.rows[i].ts < row.ts) {\n        index.rows.splice(i, 0, row)\n        if (timestampIsRecent(row.ts))\n          index.emit('add', row)\n        return row\n      }\n    }\n    index.rows.push(row)\n    if (timestampIsRecent(row.ts))\n      index.emit('add', row)\n    return row\n  }\n\n  index.sortedUpdate = function (ts, key) {\n    var i = index.indexOf(key)\n    if (i !== -1) {\n      // readd to index at new TS\n      if (index.rows[i].ts < ts) {\n        var row = index.rows[i]\n        // remove from old position\n        index.rows.splice(i, 1)\n        // update values\n        row.ts = ts\n        // reinsert\n        index.sortedInsert(row)\n        return row\n      } else\n        return index.rows[i]\n    }\n  }\n\n  index.sortedUpsert = function (ts, key) {\n    var row = index.sortedUpdate(ts, key)\n    if (!row) {\n      // add to index\n      row = index.sortedInsert(ts, key)\n    }\n    return row\n  }\n\n  index.remove = function (key, keyname) {\n    var i = index.indexOf(key, keyname)\n    if (i !== -1)\n      index.rows.splice(i, 1)\n  }\n\n  index.indexOf = function (key, keyname) {\n    keyname = keyname || 'key'\n    for (var i=0; i < index.rows.length; i++) {\n      if (index.rows[i][keyname] === key)\n        return i\n    }\n    return -1\n  }\n\n  index.find = function (key, keyname) {\n    var i = index.indexOf(key, keyname)\n    if (i !== -1)\n      return index.rows[i]\n    return null\n  }\n\n  index.contains = function (key) {\n    return index.indexOf(index, key) !== -1\n  }\n\n  index.filter = index.rows.filter.bind(index.rows)\n\n  // helper to count # of messages that are new\n  index.countUntouched = function () {\n    // iterate until we find a ts older than lastAccessed, then return that #\n    for (var i=0; i < index.rows.length; i++) {\n      if (index.rows[i].ts < index.lastAccessed)\n        return i\n    }\n    return 0\n  }\n\n  function timestampIsRecent (ts) {\n    var now = Date.now()\n    var delta = Math.abs(now - ts)\n    return (delta < IS_RECENT_MAX)\n  }\n\n  return index\n}\n\nmodule.exports.getThreadHasUnread = function (sbot, msg, cb) {\n  threadlib.getParentPostSummary(sbot, msg, { isRead: true }, function (err, thread) {\n    if (err) return cb(err)\n    cb(err, thread.hasUnread)\n  })\n}\n\nmodule.exports.findLink = function (links, id) {\n  for (var i=0; i < (links ? links.length : 0); i++) {\n    if (links[i].link === id)\n      return links[i]\n  }\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/api/manifest.js":"module.exports = {\n  createEventStream: 'source',\n\n  getIndexCounts: 'async',\n  createInboxStream: 'source',\n  createBookmarkStream: 'source',\n  createMentionStream: 'source',\n  createNoticeStream: 'source',\n  createPrivatePostStream: 'source',\n  createPublicPostStream: 'source',\n  createChannelStream: 'source',\n  createSearchStream: 'source',\n\n  markRead: 'async',\n  markUnread: 'async',\n  markAllRead: 'async',\n  toggleRead: 'async',\n  isRead: 'async',\n\n  bookmark: 'async',\n  unbookmark: 'async',\n  toggleBookmark: 'async',\n  isBookmarked: 'async',\n\n  getChannels: 'async',\n  pinChannel: 'async',\n  unpinChannel: 'async',\n  toggleChannelPinned: 'async',\n  watchChannel: 'async',\n  unwatchChannel: 'async',\n  toggleChannelWatched: 'async',\n\n  addFileToBlobs: 'async',\n  saveBlobToFile: 'async',\n\n  useLookupCode: 'source',\n\n  getMyProfile: 'async',\n  getProfile: 'async',\n  getAllProfiles: 'async',\n\n  getNamesById: 'async',\n  getIdsByName: 'async',\n  getName: 'async',\n  getActionItems: 'async'\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/api/permissions.js":"module.exports = { anonymous: { allow: [] } } // allow nothing unless master","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/api/processor.js":"var mlib = require('ssb-msgs')\nvar u = require('./util')\n\nmodule.exports = function (sbot, db, state, emit) {\n\n  var processors = {\n    post: function (msg) {\n      var me = getProfile(sbot.id)\n      var author = msg.value.author\n      var by_me = (author === sbot.id)\n      var c = msg.value.content\n      var root = mlib.link(c.root, 'msg')\n      var recps = mlib.links(c.recps)\n      var mentions = mlib.links(c.mentions)\n\n      // inbox index:\n      // add msgs that mention or address the user\n      var inboxRow\n      if (u.findLink(mentions, sbot.id) || u.findLink(recps, sbot.id)) {\n        // if a reply, make sure we have the root already\n        if (root)\n          inboxRow = state.inbox.sortedUpdate(msg.received, root.link)\n        if (!inboxRow) {\n          // fallback to inserting the current message, if the root isnt available (or its not a reply)\n          inboxRow = state.inbox.sortedUpsert(msg.received, msg.key)\n        }\n        emit('index-change', { index: 'inbox' })\n        attachChildIsRead(inboxRow, msg.key)\n      }\n      // update for replies\n      else if (root) {\n        inboxRow = state.inbox.find(root.link)\n        if (inboxRow) {\n          state.inbox.sortedUpsert(msg.received, root.link)\n          emit('index-change', { index: 'inbox' })\n          attachChildIsRead(inboxRow, msg.key)\n        }\n      }\n\n      // inbox sub-indexes\n      // note, these sub-indexes shouldnt have overlap: thus the else/if\n      // private posts index\n      var bookmarkRow\n      if (u.findLink(recps, sbot.id)) {\n        var privatePostsRow\n        // update replies\n        if (root) {\n          privatePostsRow = state.privatePosts.find(root.link)\n          if (privatePostsRow) {\n            state.privatePosts.sortedUpsert(ts(msg), root.link)\n            emit('index-change', { index: 'privatePosts' })\n            attachChildIsRead(privatePostsRow, msg.key)\n          }\n        }\n        // add msgs addressed to the user\n        else if (!privatePostsRow) {        \n          privatePostsRow = state.privatePosts.sortedUpsert(ts(msg), root ? root.link : msg.key)\n          emit('index-change', { index: 'privatePosts' })\n          attachChildIsRead(privatePostsRow, msg.key)\n        }\n      }\n      // bookmarks index: update for replies\n      else if (root && (bookmarkRow = state.bookmarks.find(root.link))) {\n        state.bookmarks.sortedUpsert(ts(msg), root.link)\n        emit('index-change', { index: 'bookmarks' })\n        attachChildIsRead(bookmarkRow, msg.key)\n      }\n      // mentions index: add msgs that mention the user\n      else if (u.findLink(mentions, sbot.id)) {\n        var mentionRow = state.mentions.sortedUpsert(ts(msg), root ? root.link : msg.key)\n        emit('index-change', { index: 'mentions' })\n        attachChildIsRead(mentionRow, msg.key)\n      }\n\n      // public posts index: add public posts / replies\n      if (recps.length === 0) {\n        state.publicPosts.sortedUpsert(ts(msg), root ? root.link : msg.key)\n        emit('index-change', { index: 'publicPosts' })\n      }\n\n      if (c.channel && typeof c.channel === 'string') {\n        // channels index: add public posts / replies\n        var indexName = 'channel-'+c.channel\n        var index = state[indexName] = (state[indexName] || u.index(indexName))\n        index.sortedUpsert(msg.value.timestamp, root ? root.link : msg.key)\n        emit('index-change', { index: indexName })\n\n        // inbox index: add watched channels\n        if (index.watched) {\n          var inboxRow\n          if (root)\n            // only do updates if a reply, we dont want inbox items that dont have a root\n            inboxRow = state.inbox.sortedUpdate(ts(msg), root.link)\n          else\n            inboxRow = state.inbox.sortedInsert(ts(msg), msg.key)\n          if (inboxRow) {\n            emit('index-change', { index: 'inbox' })\n            attachChildIsRead(inboxRow, msg.key)\n          }\n        }\n      }\n    },\n\n    contact: function (msg) {      \n      mlib.links(msg.value.content.contact, 'feed').forEach(function (link) {\n        // update profiles\n        var toself = link.link === msg.value.author\n        if (toself) updateSelfContact(msg.value.author, msg)\n        else        updateOtherContact(msg.value.author, link.link, msg)\n\n        // notices index: add follows or blocks\n        if (link.link === sbot.id && ('following' in msg.value.content || 'blocking' in msg.value.content)) {\n          state.notices.sortedUpsert(ts(msg), msg.key)\n          emit('index-change', { index: 'notices' })\n        }\n      })\n    },\n\n    about: function (msg) {\n      // update profiles\n      mlib.links(msg.value.content.about, 'feed').forEach(function (link) {\n        var toself = link.link === msg.value.author\n        if (toself) updateSelfContact(msg.value.author, msg)\n        else        updateOtherContact(msg.value.author, link.link, msg)\n      })\n    },\n\n    vote: function (msg) {\n      // notices index: add upvotes on your messages\n      var msgLink = mlib.link(msg.value.content.vote, 'msg')\n      if (msgLink && state.mymsgs.indexOf(msgLink.link) >= 0 && msgLink.value > 0) {\n        state.notices.sortedUpsert(ts(msg), msg.key)\n        emit('index-change', { index: 'notices' })\n      }\n\n      // user flags\n      var voteLink = mlib.link(msg.value.content.vote, 'feed')\n      if (voteLink) {\n        var target = getProfile(voteLink.link)\n        if (voteLink.value < 0)\n          target.flaggers[msg.value.author] = { msgKey: msg.key, reason: voteLink.reason }\n        else\n          delete target.flaggers[msg.value.author]\n      }\n    }\n  }\n\n  function getProfile (pid) {\n    if (pid.id) // already a profile?\n      return pid\n\n    var profile = state.profiles[pid]\n    if (!profile) {\n      state.profiles[pid] = profile = {\n        id: pid,\n        self: { name: null, image: null }, // values set by this user about this user\n        byMe: { name: null, image: null }, // values set by the local user about this user\n        names: {}, // map of name -> array of users to use that name\n        images: {}, // map of images -> array of users to use that pic\n        followers: {}, // map of followers -> true\n        flaggers: {}, // map of flaggers -> flag-msg\n      }\n    }\n    return profile\n  }\n\n  function updateSelfContact (author, msg) {\n    var c = msg.value.content\n    author = getProfile(author)\n\n    // name: a non-empty string\n    if (nonEmptyStr(c.name)) {\n      var safeName = makeNameSafe(c.name)\n\n      // remove old assignment, if it exists\n      for (var name in author.names) {\n        author.names[name] = author.names[name].filter(function (id) { return id !== author.id })\n        if (!author.names[name][0])\n          delete author.names[name]\n      }\n\n      // add new assignment\n      author.self.name = safeName\n      author.names[safeName] = (author.names[safeName]||[]).concat(author.id)\n      rebuildNamesFor(author)\n    }\n\n    // image: link to image\n    if ('image' in c) {\n      var imageLink = mlib.link(c.image, 'blob')\n      if (imageLink) {\n        // remove old assignment, if it exists\n        for (var image in author.images) {\n          author.images[image] = author.images[image].filter(function (id) { return id !== author.id })\n          if (!author.images[image][0])\n            delete author.images[image]\n        }\n\n        // add new assignment\n        author.self.image = imageLink\n        if (author.id == sbot.id)\n          author.byMe.image = imageLink\n        author.images[imageLink.link] = (author.images[imageLink.link]||[]).concat(author.id)\n      }\n    }\n  }\n\n  function updateOtherContact (source, target, msg) {\n    var c = msg.value.content\n    source = getProfile(source)\n    target = getProfile(target)\n\n    // name: a non-empty string\n    if (nonEmptyStr(c.name)) {\n      var safeName = makeNameSafe(c.name)\n\n      // remove old assignment, if it exists\n      for (var name in target.names) {\n        target.names[name] = target.names[name].filter(function (id) { return id !== source.id })\n        if (!target.names[name][0])\n          delete target.names[name]\n      }\n\n      // add new assignment\n      target.names[safeName] = (target.names[safeName]||[]).concat(source.id)\n      if (source.id === sbot.id)\n        target.byMe.name = safeName\n      rebuildNamesFor(target)\n    }\n\n    // image: link to image\n    if ('image' in c) {\n      var imageLink = mlib.link(c.image, 'blob')\n      if (imageLink) {\n        // remove old assignment, if it exists\n        for (var image in target.images) {\n          target.images[image] = target.images[image].filter(function (id) { return id !== source.id })\n          if (!target.images[image][0])\n            delete target.images[image]\n        }\n\n        // add new assignment\n        target.images[imageLink.link] = (target.images[imageLink.link]||[]).concat(source.id)\n        if (source.id == sbot.id)\n          target.byMe.image = imageLink\n      }\n    }\n\n    // following: bool\n    if (typeof c.following === 'boolean') {\n      if (c.following)\n        target.followers[source.id] = true\n      else\n        delete target.followers[source.id]\n\n      // if from the user, update names (in case un/following changes conflict status)\n      if (msg.value.author == sbot.id)\n        rebuildNamesFor(target)\n    }\n  }\n\n  function rebuildNamesFor (profile) {\n    profile = getProfile(profile)\n\n    // remove oldname from id->name map\n    var oldname = state.names[profile.id]\n    if (oldname) {\n      if (state.ids[oldname] == profile.id) {\n        // remove\n        delete state.ids[oldname]\n      } else if (Array.isArray(state.ids[oldname])) {\n        // is in a conflict, remove from conflict array\n        var i = state.ids[oldname].indexOf(profile.id)\n        if (i !== -1) {\n          state.ids[oldname].splice(i, 1)\n          if (state.ids[oldname].length === 1) {\n            // conflict resolved\n            delete state.actionItems[oldname]\n            state.ids[oldname] = state.ids[oldname][0]\n          }\n        }\n      }\n    }\n\n    // default to self-assigned name\n    var name = profile.self.name\n\n    // override with name assigned by the local user\n    if (profile.id !== sbot.id && profile.byMe.name)\n      name = profile.byMe.name\n\n    // abort if there's no name at all\n    if (!name)\n      return\n\n    // store\n    state.names[profile.id] = name\n\n    // if following, update id->name map\n    if (profile.id === sbot.id || profile.followers[sbot.id]) {\n      if (!state.ids[name]) { // no conflict?\n        // take it\n        state.ids[name] = profile.id\n      } else {\n        // keep track of all assigned ids\n        if (Array.isArray(state.ids[name]))\n          state.ids[name].push(profile.id)\n        else\n          state.ids[name] = [state.ids[name], profile.id]\n        // conflict, this needs to be handled by the user\n        state.actionItems[name] = {\n          type: 'name-conflict',\n          name: name,\n          ids: state.ids[name]\n        }\n      }\n    }\n  }\n\n  function attachIsRead (indexRow, key) {\n    key = key || indexRow.key\n    state.pinc()\n    db.isread.get(key, function (err, v) {\n      indexRow.isread = !!v\n      state.pdec()\n    })\n  }\n\n  // look up the child and root isread state, combine them with the current row's isread state\n  function attachChildIsRead (indexRow, childKey, cb) {\n    state.pinc()\n    var rootIsRead, childIsRead\n\n    // get child isread\n    db.isread.get(childKey, function (err, v) {\n      childIsRead = !!v\n      next()\n    })\n\n    // lookup the root isread from DB if not already on the row\n    if (typeof indexRow.isread == 'boolean') {\n      rootIsRead = indexRow.isread\n    } else {\n      db.isread.get(indexRow.key, function (err, v) {\n        rootIsRead = !!v\n        next()\n      })      \n    }\n\n    function next () {\n      // wait for both\n      if (typeof rootIsRead != 'boolean' || typeof childIsRead != 'boolean')\n        return\n\n      // combine child and root isread state\n      indexRow.isread = rootIsRead && childIsRead\n      \n      cb && cb(null, indexRow.isread)\n      state.pdec() // call this last, after all async work is done\n    }\n  }\n\n  function follows (a, b) {\n    if (a.id) a = a.id // if `a` is a profile, just get its id\n    if (b.id) b = b.id // if `b` is a profile, just get its id\n    return (a != b && getProfile(b).followers[a])\n  }\n\n  // helper to get the most reliable timestamp for a message\n  // - stops somebody from boosting their ranking (accidentally, maliciously) with a future TS\n  // - applies only when ordering by most-recent\n  function ts (msg) {\n    return Math.min(msg.received, msg.value.timestamp)\n  }\n\n  // exported api\n\n  function fn (logkey) {\n    state.pinc()\n    var key = logkey.value\n    sbot.get(logkey.value, function (err, value) {\n      var msg = { key: key, value: value, received: logkey.key }\n      try {\n        // encrypted? try to decrypt\n        if (typeof value.content == 'string' && value.content.slice(-4) == '.box') {\n          value.content = sbot.private.unbox(value.content)\n          if (!value.content)\n            return state.pdec()\n        }\n\n        // collect keys of user's messages\n        if (msg.value.author === sbot.id)\n          state.mymsgs.push(msg.key)\n\n        // type processing\n        var process = processors[msg.value.content.type]\n        if (process)\n          process(msg)\n      }\n      catch (e) {\n        // :TODO: use sbot logging plugin\n        console.error('Failed to process message', e, e.stack, key, value)\n      }\n      state.pdec()\n    })\n  }\n\n  return fn\n}\n\nfunction nonEmptyStr (str) {\n    return (typeof str === 'string' && !!(''+str).trim())\n  }\n\n// allow A-z0-9._-, dont allow a trailing .\nvar badNameCharsRegex = /[^A-z0-9\\._-]/g\nfunction makeNameSafe (str) {\n  str = str.replace(badNameCharsRegex, '_')\n  if (str.charAt(str.length - 1) == '.')\n    str = str.slice(0, -1) + '_'\n  return str\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/electron/menu.js":"var Menu = require('electron').Menu\nvar dialog = require('electron').dialog\nvar pkg = require('../package')\nvar windows = require('./windows')\nvar path = require('path')\nvar t = require('patchwork-translations')\n\nvar isMac = (process.platform == 'darwin')\n\nfunction showAbout(win) {\n  dialog.showMessageBox(win, {\n    title: t('AboutPatchwork'),\n    buttons: [t('Close'), t('License')],\n    type: 'info',\n    icon: path.join(__dirname, '../ui/img/icon.png'),\n    message: pkg.name + ' v' + pkg.version,\n    detail: pkg.description + '\\n\\n' +\n      t('Copyright', {years: '2016-2016'}) + '\\n\\n' +\n      'http://ssbc.github.io/patchwork/'\n  }, function (btn) {\n    if (btn == 1)\n      showLicense(win)\n  })\n}\n\nfunction showLicense(win) {\n  dialog.showMessageBox(win, {\n    title: t('License'),\n    buttons: [t('Close')],\n    message: pkg.license,\n    detail: t('LicenseDialog')\n  })\n}\n\nmodule.exports = function (configOracle) {\n  var template = [\n    {\n      label: t('Patchwork'),\n      submenu: [\n        {\n          label: t('AboutPatchwork'),\n          role: 'about',\n          click: function (item, win) {\n            showAbout(win)\n          }\n        },\n      ].concat(isMac ? [\n        {\n          type: 'separator'\n        },\n        {\n          label: t('macApp.HidePatchwork'),\n          accelerator: 'Command+H',\n          selector: 'hide:',\n          role: 'hide'\n        },\n        {\n          label: t('macApp.HideOthers'),\n          accelerator: 'Option+Command+H',\n          selector: 'hideOtherApplications:',\n        role: 'hideothers'\n        },\n        {\n          label: t('macApp.ShowAll'),\n          selector: 'unhideAllApplications:',\n          role: 'unhide'\n        },\n      ] : [], [\n        {\n          type: 'separator'\n        },\n        {\n          label: t('Quit'),\n          accelerator: 'CmdOrCtrl+Q',\n          click: function (item, win) {\n            require('electron').app.quit()\n          }\n        }\n      ])\n    },\n    {\n      label: t('Edit'),\n      submenu: [\n        {\n          label: t('Undo'),\n          accelerator: 'CmdOrCtrl+Z',\n          role: 'undo'\n        },\n        {\n          label: t('Redo'),\n          accelerator: 'Shift+CmdOrCtrl+Z',\n          role: 'redo'\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: t('Cut'),\n          accelerator: 'CmdOrCtrl+X',\n          role: 'cut'\n        },\n        {\n          label: t('Copy'),\n          accelerator: 'CmdOrCtrl+C',\n          role: 'copy'\n        },\n        {\n          label: t('Paste'),\n          accelerator: 'CmdOrCtrl+V',\n          role: 'paste'\n        },\n        {\n          label: t('SelectAll'),\n          accelerator: 'CmdOrCtrl+A',\n          role: 'selectall'\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: t('Find2'),\n          accelerator: 'CmdOrCtrl+F',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.emit(\"focus:find\")')\n          }\n        },\n        {\n          label: t('FindNext'),\n          accelerator: 'CmdOrCtrl+G',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.emit(\"find:next\")')\n          }\n        },\n        {\n          label: t('FindPrevious'),\n          accelerator: 'CmdOrCtrl+Shift+G',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.emit(\"find:previous\")')\n          }\n        }\n      ]\n    },\n    {\n      label: t('View'),\n      submenu: [\n        {\n          label: t('ZoomIn'),\n          accelerator: 'CmdOrCtrl+=',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('window.zoom.zoomIn()')\n          }\n        },\n        {\n          label: t('ZoomOut'),\n          accelerator: 'CmdOrCtrl+-',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('window.zoom.zoomOut()')\n          }\n        },\n        {\n          label: t('NormalSize'),\n          accelerator: 'CmdOrCtrl+0',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('window.zoom.zoomReset()')\n          }\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: t('ToggleDevTools'),\n          accelerator: isMac ? 'Alt+Command+I' : 'Ctrl+Shift+I',\n          click: function (item, win) { \n            win.toggleDevTools()\n          }\n        }\n      ]\n    },\n    {\n      label: t('Go'),\n      submenu: [\n        {\n          label: t('Back'),\n          accelerator: 'Alt+Left',\n          click: function (item, win) {\n            win.webContents.goBack()\n          }\n        },\n        {\n          label: t('Forward'),\n          accelerator: 'Alt+Right',\n          click: function (item, win) {\n            win.webContents.goForward()\n          }\n        },\n        {\n          label: t('Reload'),\n          accelerator: 'CmdOrCtrl+R',\n          click: function (item, win) {\n            win.reload()\n          }\n        },\n        {\n          type: 'separator'\n        },\n\n        {\n          label: t('Inbox'),\n          accelerator: 'CmdOrCtrl+1',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"\")')\n          }\n        },\n        {\n          label: t('ActivityFeed'),\n          accelerator: 'CmdOrCtrl+2',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"activity\")')\n          }\n        },\n        {\n          label: t('Contacts'),\n          accelerator: 'CmdOrCtrl+3',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"contacts\")')\n          }\n        },\n\n        {\n          type: 'separator'\n        },\n\n        {\n          label: t('NoticesMenuItem'),\n          accelerator: 'CmdOrCtrl+Shift+D',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"notices\")')\n          }\n        },\n        {\n          label: t('YourProfile'),\n          accelerator: 'CmdOrCtrl+Shift+P',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"profile/\" + encodeURIComponent(app.user.id))')\n          }\n        },\n\n        {\n          label: t('NetworkSync'),\n          accelerator: 'CmdOrCtrl+4',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"sync\")')\n          }\n        },\n        {\n          label: t('DataFeed'),\n          accelerator: 'CmdOrCtrl+5',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.history.pushState(null, \"data\")')\n          }\n        },\n\n        {\n          type: 'separator'\n        },\n        {\n          label: t('Search'),\n          accelerator: 'CmdOrCtrl+K',\n          click: function (item, win) {\n            win.webContents.executeJavaScript('app.emit(\"focus:search\")')\n          }\n        }\n      ]\n    },\n    {\n      label: 'Window',\n      submenu: [\n        {\n          label: t('NewWindow'),\n          accelerator: 'CmdOrCtrl+N',\n          click: function (item, win) {\n            var newWindow = windows.create()\n            newWindow.loadURL(configOracle.getLocalUrl())\n          }\n        },\n        {\n          label: t('Close'),\n          accelerator: 'CmdOrCtrl+W',\n          click: function (item, win) {\n            win.close()\n          }\n        },\n      ].concat(isMac ? [\n        {\n          label: t('Minimize'),\n          accelerator: 'CmdOrCtrl+M',\n          role: 'minimize'\n        },\n        {\n          type: 'separator'\n        },\n        {\n          label: t('macApp.BringAllToFront'),\n          selector: 'arrangeInFront:',\n          role: 'front'\n        }\n      ] : [])\n    }\n  ]\n\n  menu = Menu.buildFromTemplate(template)\n  Menu.setApplicationMenu(menu)\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/electron/windows.js":"var path = require('path')\nvar BrowserWindow = require('electron').BrowserWindow\nvar shell = require('electron').shell\nvar extend = require('xtend')\n\nvar webPreferences = {\n  nodeIntegration: false,\n  javascript: true,\n  webSecurity: true,\n  images: true,\n  java: false,\n  webgl: false, // maybe allow?\n  webaudio: false, // maybe allow?\n  plugins: false,\n  experimentalFeatures: false,\n  experimentalCanvasFeatures: false,\n  sharedWorker: false\n}\n\n// retain global references, if not, window will be closed automatically when\n// garbage collected\nvar _windows = {}\n\nfunction _createWindow (opts) {\n  var window = new BrowserWindow(opts)\n  _windows[window.id] = window\n  return window\n}\n\n// should not need to be called directly, but just in case\n// window.destroy() is ever called\nfunction _unref () {\n  delete _windows[this.id]\n}\n\nfunction create (opts) {\n  opts = extend({\n    width: 1100,\n    height: 800,\n    preload: require('path').join(__dirname, '../ui/preload.js'),\n    webPreferences: webPreferences\n  }, opts)\n\n  var window = _createWindow(opts)\n  window.unref = _unref.bind(window)\n  window.once('close', window.unref)\n  window.webContents.on('new-window', function (e, url) {\n    // open in the browser\n    e.preventDefault()\n    shell.openExternal(url)\n  })\n  return window\n}\n\nmodule.exports = {\n  create: create,\n  windows: _windows,\n  hasVisibleWindows: function () {\n    Object.keys(_windows).some(function (id) {\n      var window = _windows[id]\n      return window.isVisible()\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/lib/friends-with-gossip-priority.js":"var Graphmitter = require('graphmitter')\nvar pull        = require('pull-stream')\nvar mlib        = require('ssb-msgs')\nvar memview     = require('level-memview')\nvar pushable    = require('pull-pushable')\nvar mdm         = require('mdmanifest')\nvar valid       = require('scuttlebot/lib/validators')\nvar apidoc      = require('scuttlebot/lib/apidocs').friends\n\n// friends plugin\n// methods to analyze the social graph\n// maintains a 'follow' and 'flag' graph\n\nfunction isFunction (f) {\n  return 'function' === typeof f\n}\n\nfunction isString (s) {\n  return 'string' === typeof s\n}\n\nfunction isFriend (friends, a, b) {\n  return friends[a] && friends[b] && friends[a][b] && friends[b][a]\n}\n\nexports.name = 'friends'\nexports.version = '1.0.0'\nexports.manifest = mdm.manifest(apidoc)\n\nexports.init = function (sbot, config) {\n\n  var graphs = {\n    follow: new Graphmitter(),\n    flag: new Graphmitter()\n  }\n\n  // view processor\n  var syncCbs = []\n  function awaitSync (cb) {\n    if (syncCbs) syncCbs.push(cb)\n    else cb()\n  }\n\n  // read/watch the log for changes to the social graph\n  pull(sbot.createLogStream({ live: true }), pull.drain(function (msg) {\n\n    if (msg.sync) {\n      syncCbs.forEach(function (cb) { cb() })\n      syncCbs = null\n\n      if (sbot.gossip) {\n        // prioritize friends\n        var friends = graphs['follow'].toJSON()\n        sbot.gossip.peers().forEach(function(peer) {\n          if (isFriend(friends, sbot.id, peer.key)) {\n            sbot.gossip.add(peer, 'friends')\n          }\n        })\n      }\n\n      return\n    }\n\n    var c = msg.value.content\n    if (c.type == 'contact') {\n      mlib.asLinks(c.contact, 'feed').forEach(function (link) {\n        if ('following' in c) {\n          if (c.following)\n            graphs.follow.edge(msg.value.author, link.link, true)\n          else\n            graphs.follow.del(msg.value.author, link.link)\n\n        }\n        if ('flagged' in c) {\n          if (c.flagged)\n            graphs.flag.edge(msg.value.author, link.link, c.flagged)\n          else\n            graphs.flag.del(msg.value.author, link.link)\n        }\n      })\n    }\n  }))\n\n  return {\n\n    get: valid.sync(function (opts) {\n      var g = graphs[opts.graph || 'follow']\n      if(!g) throw new Error('opts.graph must be provided')\n      return g.get(opts.source, opts.dest)\n    }, 'object?'),\n\n    all: valid.async(function (graph, cb) {\n      if (typeof graph == 'function') {\n        cb = graph\n        graph = null\n      }\n      if (!graph)\n        graph = 'follow'\n      awaitSync(function () {\n        cb(null, graphs[graph] ? graphs[graph].toJSON() : null)\n      })\n    }, 'string?'),\n\n    path: valid.sync(function (opts) {\n      if(isString(opts))\n        opts = {source: sbot.id, dest: opts}\n      return graphs.follow.path(opts)\n\n    }, 'string|object'),\n\n    createFriendStream: valid.source(function (opts) {\n      opts = opts || {}\n      var live = opts.live === true\n      var meta = opts.meta === true\n      var start = opts.start || sbot.id\n      var graph = graphs[opts.graph || 'follow']\n      if(!graph)\n        return pull.error(new Error('unknown graph:' + opts.graph))\n      var cancel, ps = pushable(function () {\n        cancel && cancel()\n      })\n\n      function push (to, hops) {\n        return ps.push(meta ? {id: to, hops: hops} : to)\n      }\n\n      //by default, also emit your own key.\n      if(opts.self !== false)\n        push(start, 0)\n\n      var conf = config.friends || {}\n      cancel = graph.traverse({\n        start: start,\n        hops: opts.hops || conf.hops || 3,\n        max: opts.dunbar || conf.dunbar || 150,\n        each: function (_, to, hops) {\n          if(to !== start) push(to, hops)\n        }\n      })\n\n      if(!live) { cancel(); ps.end() }\n\n      return ps\n    }, 'createFriendStreamOpts?'),\n\n    hops: valid.async(function (start, graph, opts, cb) {\n      if (typeof opts == 'function') { // (start|opts, graph, cb)\n        cb = opts\n        opts = null\n      } else if (typeof graph == 'function') { // (start|opts, cb)\n        cb = graph\n        opts = graph = null\n      }\n      opts = opts || {}\n      if(isString(start)) { // (start, ...)\n        // first arg is id string\n        opts.start = start\n      } else if (start && typeof start == 'object') { // (opts, ...)\n        // first arg is opts\n        for (var k in start)\n          opts[k] = start[k]\n      }\n\n      var conf = config.friends || {}\n      opts.start  = opts.start  || sbot.id\n      opts.dunbar = opts.dunbar || conf.dunbar || 150\n      opts.hops   = opts.hops   || conf.hops   || 3\n\n      var g = graphs[graph || 'follow']\n      if (!g)\n        return cb(new Error('Invalid graph type: '+graph))\n\n      awaitSync(function () {\n        cb(null, g.traverse(opts))\n      })\n    }, ['feedId', 'string?', 'object?'], ['createFriendStreamOpts'])\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/loading.js":"// setup basic error-handling, in case app fails to load\n\n(function () {\n\nvar locales = {\n  da: {\n    LoadingError: \"Beklager! Patchwork løbt ind i den fejl under indlæsning.\",\n    Loading: \"Indlæser...\"\n  },\n  en: {\n    LoadingError: \"We're sorry! Patchwork experienced an error while loading.\",\n    Loading: \"Loading...\"\n  },\n  \"pt-BR\": {\n    LoadingError: \"Lamentamos! Ocorreu um erro ao carregar o Patchwork.\",\n    Loading: \"Carregando...\"\n  },\n  \"pt-PT\": {\n    LoadingError: \"Pedimos desculpa! Ocorreu um erro ao carregar o Patchwork.\",\n    Loading: \"Carregando...\"\n  },\n  \"zh-cn\": {\n    LoadingError: \"抱歉！Patchwork加载时出现问题。\",\n    Loading: \"载入中...\"\n  }\n}\n\nfunction tryLocale(locale) {\n  if (locale in locales) return locale\n  locale = String(locale).replace(/[._].*$/, '')\n  if (locale in locales) return locale\n}\n\nfunction t(str) {\n  var locale = tryLocale(localStorage.locale)\n            || tryLocale(navigator.language)\n            || 'en'\n  return locales[locale][str]\n}\n\nwindow.loadErrorHandler = function (e) {\n  console.error(e.error || e)\n\n  // hide spinner\n  document.querySelector('.loading').style.display = 'none'\n\n  // render heading\n  var h1 = document.createElement('h1')\n  h1.innerText = t('LoadingError')\n  h1.style.margin = '10px'\n  document.body.appendChild(h1)\n\n  // render stack\n  var pre = document.createElement('pre')\n  pre.style.margin = '10px'\n  pre.style.padding = '10px'\n  pre.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)'\n  pre.innerText = e.error ? (e.error.stack || e.error.toString()) : e.message\n  document.body.appendChild(pre)\n}\nwindow.addEventListener('error', window.loadErrorHandler)\n\ndocument.querySelector('.loading').title = t('Loading')\n\n})()","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/main.js":"'use strict'\n\nvar pull     = require('pull-stream')\nvar ReactDOM = require('react-dom')\n\n// Init\n// ====\n\n// master state object\nwindow.app = require('./lib/app')\nwindow.pull = pull // pull is useful for debugging\n\n// toplevel events\nwindow.addEventListener('error', onError)\n\n// init language\nvar t = require('patchwork-translations')\nt.setLocale(localStorage.locale || navigator.language)\n\n// render\napp.fetchLatestState(function () {\n  // redirect to contacts page if new-user setup is occurring\n  // that's where where we want the user to land after the modal flow\n  if (app.user.needsSetup)\n    app.history.pushState(null, '/contacts')\n\n\n  // begin rendering\n  var routes = require('./routes.jsx')\n  document.body.removeChild(document.querySelector('.loading'))\n  ReactDOM.render(routes.routes, document.body.querySelector('div'))\n  window.removeEventListener('error', window.loadErrorHandler)\n})\n\n// Handlers\n// ========\n\nfunction onError (e) {\n  e.preventDefault()\n  app.minorIssue('Unexpected Error', e.error || e, 'This was an unhandled exception.')\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/preload.js":"console.log('Running electron preload')\nwindow.electron = {}\n\n// add context menu\nwindow.addEventListener('contextmenu', require('./electron/context-menu'))\n\n// add zoom controls\nwindow.zoom = require('./electron/zoom')","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/lib/persistent-gossip/init.js":"var isArray = Array.isArray\nvar pull = require('pull-stream')\nvar ref = require('ssb-ref')\n\nmodule.exports = function (gossip, config, server) {\n\n  // populate peertable with configured seeds (mainly used in testing)\n  var seeds = config.seeds\n\n  ;(isArray(seeds)  ? seeds : [seeds]).filter(Boolean)\n  .forEach(function (addr) { gossip.add(addr, 'seed') })\n\n  // populate peertable with pub announcements on the feed\n  pull(\n    server.messagesByType({\n      type: 'pub', live: true, keys: false\n    }),\n    pull.drain(function (msg) {\n      if(msg.sync) return\n      if(!msg.content.address) return\n      if(ref.isAddress(msg.content.address))\n        gossip.add(msg.content.address, 'pub')\n    })\n  )\n\n  // populate peertable with announcements on the LAN multicast\n  server.on('local', function (_peer) {\n    gossip.add(_peer, 'local')\n  })\n\n}\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/lib/persistent-gossip/schedule.js":"var ip = require('ip')\nvar onWakeup = require('on-wakeup')\nvar onNetwork = require('on-change-network')\nvar hasNetwork = require('has-network')\n\nvar pull = require('pull-stream')\n\nfunction not (fn) {\n  return function (e) { return !fn(e) }\n}\n\nfunction and () {\n  var args = [].slice.call(arguments)\n  return function (value) {\n    return args.every(function (fn) { return fn.call(null, value) })\n  }\n}\n\n//min delay (delay since last disconnect of most recent peer in unconnected set)\n//unconnected filter delay peer < min delay\nfunction delay (failures, factor, max) {\n  return Math.min(Math.pow(2, failures)*factor, max || Infinity)\n}\n\nfunction maxStateChange (M, e) {\n  return Math.max(M, e.stateChange || 0)\n}\n\nfunction peerNext(peer, opts) {\n  return (peer.stateChange|0) + delay(peer.failure|0, opts.factor, opts.max)\n}\n\n\n//detect if not connected to wifi or other network\n//(i.e. if there is only localhost)\n\nfunction isOffline (e) {\n  if(ip.isLoopback(e.host)) return false\n  return !hasNetwork()\n}\n\nvar isOnline = not(isOffline)\n\nfunction isLocal (e) {\n  // don't rely on private ip address, because\n  // cjdns creates fake private ip addresses.\n  return ip.isPrivate(e.host) && e.source === 'local'\n}\n\nfunction isFriend (e) {\n  return e.source === 'friends'\n}\n\nfunction isUnattempted (e) {\n  return !e.stateChange\n}\n\n//select peers which have never been successfully connected to yet,\n//but have been tried.\nfunction isInactive (e) {\n  return e.stateChange && (!e.duration || e.duration.mean == 0)\n}\n\nfunction isLongterm (e) {\n  return e.ping && e.ping.rtt && e.ping.rtt.mean > 0\n}\n\n//peers which we can connect to, but are not upgraded.\n//select peers which we can connect to, but are not upgraded to LT.\n//assume any peer is legacy, until we know otherwise...\nfunction isLegacy (peer) {\n  return peer.duration && peer.duration.mean > 0 && !exports.isLongterm(peer)\n}\n\nfunction isConnect (e) {\n  return 'connected' === e.state || 'connecting' === e.state\n}\n\n//sort oldest to newest then take first n\nfunction earliest(peers, n) {\n  return peers.sort(function (a, b) {\n    return a.stateChange - b.stateChange\n  }).slice(0, Math.max(n, 0))\n}\n\nfunction select(peers, ts, filter, opts) {\n  if(opts.disable) return []\n  //opts: { quota, groupMin, min, factor, max }\n  var type = peers.filter(filter)\n  var unconnect = type.filter(not(isConnect))\n  var count = Math.max(opts.quota - type.filter(isConnect).length, 0)\n  var min = unconnect.reduce(maxStateChange, 0) + opts.groupMin\n  if(ts < min) return []\n\n  return earliest(unconnect.filter(function (peer) {\n    return peerNext(peer, opts) < ts\n  }), count)\n}\n\nvar schedule = exports = module.exports =\nfunction (gossip, config, server) {\n//  return\n  var min = 60e3, hour = 60*60e3\n\n  //trigger hard reconnect after suspend or local network changes\n  onWakeup(gossip.reconnect)\n  onNetwork(gossip.reconnect)\n\n  function conf(name, def) {\n    if(!config.gossip) return def\n    var value = config.gossip[name]\n    return (value === undefined || value === '') ? def : value\n  }\n\n  function connect (peers, ts, name, filter, opts) {\n    opts.group = name\n    var connected = peers.filter(isConnect).filter(filter)\n\n    //disconnect if over quota\n    if(connected.length > opts.quota) {\n      return earliest(connected, connected.length - opts.quota)\n        .forEach(function (peer) {\n          gossip.disconnect(peer)\n        })\n    }\n\n    //will return [] if the quota is full\n    var selected = select(peers, ts, and(filter, isOnline), opts)\n    selected\n      .forEach(function (peer) {\n        gossip.connect(peer)\n      })\n  }\n\n\n  var connecting = false\n  function connections () {\n    if(connecting) return\n    connecting = true\n    setTimeout(function () {\n      connecting = false\n      var ts = Date.now()\n      var peers = gossip.peers()\n\n      var connected = peers.filter(and(isConnect, not(isLocal), not(isFriend))).length\n      var connectedFriends = peers.filter(and(isConnect, isFriend)).length\n\n      connect(peers, ts, 'local', exports.isLocal, {\n        quota: 3, factor: 2e3, max: 10*min, groupMin: 1e3,\n        disable: !conf('local', true)\n      })\n\n      // prioritize friends\n      connect(peers, ts, 'friends', and(exports.isFriend, exports.isLongterm), {\n        quota: 2, factor: 10e3, max: 10*min, groupMin: 5e3,\n        disable: !conf('local', true)\n      })\n\n      if (connectedFriends < 2)\n        connect(peers, ts, 'attemptFriend', and(exports.isFriend, exports.isUnattempted), {\n          min: 0, quota: 1, factor: 0, max: 0, groupMin: 0,\n          disable: !conf('global', true)\n        })\n\n      connect(peers, ts, 'retryFriends', and(exports.isFriend, exports.isInactive), {\n        min: 0,\n        quota: 3, factor: 60e3, max: 3*60*60e3, groupMin: 5*60e3\n      })\n\n      // standard longterm peers\n      connect(peers, ts, 'longterm', and(\n        exports.isLongterm,\n        not(exports.isFriend),\n        not(exports.isLocal)\n      ), {\n        quota: 2, factor: 10e3, max: 10*min, groupMin: 5e3,\n        disable: !conf('global', true)\n      })\n\n      if(!connected)\n        connect(peers, ts, 'attempt', exports.isUnattempted, {\n          min: 0, quota: 1, factor: 0, max: 0, groupMin: 0,\n          disable: !conf('global', true)\n        })\n\n      //quota, groupMin, min, factor, max\n      connect(peers, ts, 'retry', exports.isInactive, {\n        min: 0,\n        quota: 3, factor: 5*60e3, max: 3*60*60e3, groupMin: 5*50e3\n      })\n\n      var longterm = peers.filter(isConnect).filter(exports.isLongterm).length\n\n      connect(peers, ts, 'legacy', exports.isLegacy, {\n        quota: 3 - longterm,\n        factor: 5*min, max: 3*hour, groupMin: 5*min,\n        disable: !conf('global', true)\n      })\n\n      peers.filter(isConnect).forEach(function (e) {\n        var permanent = exports.isLongterm(e) || exports.isLocal(e)\n        if((!permanent || e.state === 'connecting') && e.stateChange + 10e3 < ts) {\n          gossip.disconnect(e)\n        }\n      })\n\n    }, 100*Math.random())\n\n  }\n\n    pull(\n      gossip.changes(),\n      pull.drain(function (ev) {\n        if(ev.type == 'disconnect')\n          connections()\n      })\n    )\n\n    var int = setInterval(connections, 2e3)\n    if(int.unref) int.unref()\n\n    connections()\n\n}\n\nexports.isUnattempted = isUnattempted\nexports.isInactive = isInactive\nexports.isLongterm = isLongterm\nexports.isLegacy = isLegacy\nexports.isLocal = isLocal\nexports.isFriend = isFriend\nexports.isConnectedOrConnecting = isConnect\nexports.select = select\n","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/electron/context-menu.js":"var remote = require('remote')\nvar electron = remote.require('electron')\nvar Menu = electron.Menu\nvar MenuItem = electron.MenuItem\nvar dialog = electron.dialog\nvar clipboard = electron.clipboard\nvar ssbref = require('ssb-ref')\nvar fs = remote.require('fs')\nvar http = remote.require('http')\n\n/* using globals because putting properties on the menu didn't seem to work */\nvar currentEl\nvar currentLink\n\nvar imgMenuItems = [\n  {\n    label: 'Save Image As',\n    click: function (item, mainWindow) {\n      var img = currentEl\n      var name = img.alt || img.src\n      var m = /^http:\\/\\/localhost:7777\\/.*\\&name=([^&]*)/.exec(img.src)\n      if (m)\n        name = m[1]\n\n      dialog.showSaveDialog({\n        defaultPath: name\n      }, function (fileName) {\n        if (fileName) {\n          http.request(img.src, function (res) {\n            res.pipe(fs.createWriteStream(fileName))\n          }).end()\n        }\n      })\n    }\n  },\n  /*\n  {\n    label: 'Copy Image',\n    click: function () { }\n  },\n  */\n  {\n    label: 'Copy Image Location',\n    click: function (item) {\n      var link = currentEl.src\n      var m = /^http:\\/\\/localhost:7777\\/([^?]*)/.exec(link)\n      if (m && ssbref.isLink(m[1]))\n        link = m[1]\n      clipboard.writeText(link)\n    }\n  }\n]\n\nvar linkMenuItems = [\n  {\n    label: 'Open Link',\n    click: function (item) {\n      currentLink.click()\n    }\n  },\n  {\n    label: 'Copy Link Location',\n    click: function () {\n      var href = currentLink.getAttribute('href')\n      var m = /^#\\/[^\\/]*\\/(.*)/.exec(href)\n      if (m) {\n        var link = decodeURIComponent(m[1])\n        if (ssbref.isLink(link))\n          href = link\n      }\n      clipboard.writeText(href)\n    }\n  },\n]\n\nvar textSelectionMenuItems = [\n  {label: 'Copy', role: 'copy'}\n]\n\nvar texteditMenuItems = [\n  {label: 'Cut', role: 'cut'},\n  {label: 'Copy', role: 'copy'},\n  {label: 'Paste', role: 'paste'},\n  {label: 'Delete', click: function (item) {\n    document.execCommand('delete')\n  }},\n  {type: 'separator'},\n  {label: 'Select All', role: 'selectall'},\n]\n\nvar texteditMenuItemsNoSelection = [\n  {label: 'Cut', role: 'cut', enabled: false},\n  {label: 'Copy', role: 'copy', enabled: false},\n  {label: 'Paste', role: 'paste'},\n  {label: 'Delete', enabled: false},\n  {type: 'separator'},\n  {label: 'Select All', role: 'selectall'},\n]\n\nfunction appendMenuItemGroup(menu, items) {\n  if (menu.items.length) {\n    menu.append(new MenuItem({\n      type: 'separator'\n    }))\n  }\n  for (var i = 0; i < items.length; i++) {\n    menu.append(new MenuItem(items[i]))\n  }\n}\n\nfunction getContainingLink(el) {\n  while (el) {\n    if (el.nodeName == 'A' && el.href)\n      return el\n    el = el.parentNode\n  }\n}\n\nfunction createMenu(el) {\n  var menu = new Menu()\n  var link = getContainingLink(el)\n  currentEl = el\n\n  switch (el.nodeName) {\n    case 'IMG':\n      appendMenuItemGroup(menu, imgMenuItems)\n      break\n    case 'INPUT':\n    case 'TEXTAREA':\n      if (el.selectionEnd == el.selectionStart)\n        appendMenuItemGroup(menu, texteditMenuItemsNoSelection)\n      else\n        appendMenuItemGroup(menu, texteditMenuItems)\n      break\n    default:\n      if (!link && document.getSelection().type == 'Range')\n        appendMenuItemGroup(menu, textSelectionMenuItems)\n      break\n  }\n\n  if (link) {\n    currentLink = link\n    appendMenuItemGroup(menu, linkMenuItems)\n  }\n\n  return menu\n}\n\nmodule.exports = function onContextMenu(e) {\n  e.preventDefault()\n  var menu = createMenu(e.target)\n  if (menu)\n    menu.popup(remote.getCurrentWindow())\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/electron/zoom.js":"var webFrame = require('web-frame')\n\nvar zoomStep = 0.5\nvar zoom = +localStorage.zoom || 0\nif (zoom) {\n  webFrame.setZoomLevel(zoom)\n}\n\nfunction setZoom(z) {\n  zoom = z\n  webFrame.setZoomLevel(zoom)\n  localStorage.zoom = z\n}\n\nmodule.exports = {\n  setZoom: setZoom,\n  zoomIn: function () {\n    setZoom(zoom + zoomStep)\n  },\n  zoomOut: function () {\n    setZoom(zoom - zoomStep)\n  },\n  zoomReset: function () {\n    setZoom(0)\n  }\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/lib/app.js":"'use strict'\n\n/*\nApplication Master State\n========================\nCommon state which either exists as part of the session,\nor which has  been  loaded  from  scuttlebot during page\nrefresh because  its  commonly  needed during rendering.\n*/\n\n// constants\nvar POLL_PEER_INTERVAL = 5e3 // every 5 seconds\n\nvar multicb   = require('multicb')\nvar pull      = require('pull-stream')\nvar SSBClient = require('./ws-client')\nvar emojis    = require('emoji-named-characters')\nvar Emitter   = require('events')\nvar extend    = require('xtend/mutable')\nvar pu        = require('patchkit-util')\nvar favicon   = require('./favicon')\nvar createHashHistory = require('history').createHashHistory\nvar t         = require('patchwork-translations')\n\n// event streams and listeners\nvar patchworkEventStream = null\nvar isWatchingNetwork = false\n\n// master state object\nvar app =\nmodule.exports = extend(new Emitter(), {\n  // sbot rpc connection\n  ssb: SSBClient(),\n\n  // pull state from sbot, called on every view change\n  fetchLatestState: fetchLatestState,\n\n  // ui data\n  history: createHashHistory({ queryKey: false }),\n  isComposerOpen: false,\n  suggestOptions: { \n    ':': Object.keys(emojis).map(function (emoji) {\n      return {\n        image: './img/emoji/' + emoji + '.png',\n        title: emoji,\n        subtitle: emoji,\n        value: ':' + emoji + ':'\n      }\n    }),\n    '@': []\n  },\n  issues: [],\n  issue: addIssue.bind(null, true), // helper to add an issue\n  minorIssue: addIssue.bind(null, false), // helper to add an issue that shouldnt trigger a modal\n  notifications: [],\n  notice: addNotification,\n  dismissNotice: removeNotification,\n\n  // application state, fetched every refresh\n  actionItems: {},\n  indexCounts: {},\n  channels: [], // array of { name: str, pinned: bool, lastUpdated: ts, hasNew: bool }\n  user: {\n    id: null,\n    profile: {},\n    needsSetup: false, // does the setup flow need to occur?\n    followeds: [], // people the user follows\n    friends: [], // people the user follows, who follow the user back\n    nonfriendFolloweds: [], // people the user follows, who dont follow the user back\n    nonfriendFollowers: [] // people the user doesnt follow, who follows the user\n  },\n  users: {\n    names: {},\n    profiles: {}\n  },\n  peers: [],\n  isWifiMode: false\n})\napp.on('notice', app.notice)\n\nfunction addIssue (isUrgent, title, err, extraIssueInfo) {\n  console.error(title, err, extraIssueInfo)\n  var message = err.message || err.toString()\n  var stack   = err.stack || ''\n  var issueDesc = message + '\\n\\n' + stack + '\\n\\n' + (extraIssueInfo||'')\n\n  app.issues.unshift({\n    isRead: false,\n    isUrgent: isUrgent,\n    title: title,\n    message: message,\n    stack: stack,\n    issueUrl: 'https://github.com/ssbc/patchwork/issues/new?body='+encodeURIComponent(issueDesc)\n  })\n  app.emit('update:issues')\n}\n\nvar notificationUuidCounter = 0\nfunction addNotification (message) {\n  app.notifications.push({ key: ++notificationUuidCounter, message: message, dismissAfter: 5e3 })\n  app.emit('update:notifications')\n}\nfunction removeNotification (notification) {\n  app.notifications = app.notifications.filter(n => n !== notification)\n  app.emit('update:notifications')\n}\n\nfunction updateChannels (name, values) {\n  // upsert\n  var i\n  for (i = 0; i < app.channels.length; i++) {\n    if (app.channels[i].name === name) {\n      // immutable update - create a new object, so shouldUpdate works nicely in the channels list com\n      app.channels[i] = Object.assign({}, app.channels[i], values)\n      break\n    }\n  }\n  if (i === app.channels.length)\n    app.channels.push(Object.assign({ name: name }, values))\n\n  // sort\n  sortChannels()\n}\n\nfunction sortChannels () {\n  app.channels.sort(function (a, b) {\n    // go by last updated\n    return b.lastUpdated - a.lastUpdated\n  })\n}\n\nfunction onPatchworkEvent (e) {\n  if (e.type == 'index-change') {\n    for (var k in e.counts)\n      app.indexCounts[k] = e.counts[k]\n    app.emit('update:indexCounts')\n    updateTitle()\n    if (e.index.indexOf('channel-') === 0) {\n      updateChannels(e.index.slice('channel-'.length), { lastUpdated: Date.now() })\n      app.emit('update:channels')      \n    }\n  }\n  else if (e.type == 'isread') {\n    app.emit('update:isread', { key: e.key, value: e.value })\n  }\n  else if (e.type == 'channelpinned') {\n    updateChannels(e.channel, { pinned: e.value })\n    app.emit('update:channels')\n  }\n  else if (e.type == 'channelwatched') {\n    updateChannels(e.channel, { watched: e.value })\n    app.emit('update:channels')\n  }\n}\n\nfunction pollPeers () {\n  app.ssb.gossip.peers(function (err, peers) {\n    var isWifiMode = require('./util').getPubStats(peers).hasSyncIssue\n    app.peers = peers\n    app.emit('update:peers')\n    if (isWifiMode !== app.isWifiMode) {\n      app.isWifiMode = isWifiMode\n      app.emit('update:isWifiMode')\n    }\n  })\n}\n\nfunction updateTitle () {\n  document.title = t('Patchwork')\n  favicon.update({ label: app.indexCounts.inboxUnread })\n}\nwindow.favicon = favicon\n\nfunction fetchLatestState (cb) {\n  if (!patchworkEventStream)\n    pull((patchworkEventStream = app.ssb.patchwork.createEventStream()), pull.drain(onPatchworkEvent.bind(this)))\n  if (!isWatchingNetwork) {\n    setInterval(pollPeers, POLL_PEER_INTERVAL)\n    isWatchingNetwork = true\n  }\n\n  var done = multicb({ pluck: 1 })\n  app.ssb.whoami(done())\n  app.ssb.patchwork.getNamesById(done())\n  app.ssb.patchwork.getAllProfiles(done())\n  app.ssb.patchwork.getActionItems(done())\n  app.ssb.patchwork.getIndexCounts(done())\n  app.ssb.gossip.peers(done())\n  if (!app.channels.length)\n    app.ssb.patchwork.getChannels(done())\n  done(function (err, data) {\n    if (err) throw err.message\n    app.user.id         = data[0].id\n    app.users.names     = data[1]\n    app.users.profiles  = data[2]\n    app.actionItems     = data[3]\n    app.indexCounts     = data[4]\n    app.peers           = data[5]\n    if (data[6]) {\n      app.channels        = data[6]\n      sortChannels()\n    }\n    app.isWifiMode      = require('./util').getPubStats(app.peers).hasSyncIssue\n    app.user.profile    = app.users.profiles[app.user.id]\n    app.user.needsSetup = !app.users.names[app.user.id]\n    updateTitle()\n\n    // get friend list\n    var social = require('patchkit-util/social')\n    app.user.followeds = social.followeds(app.users, app.user.id)\n    app.user.friends = app.user.followeds.filter(function (other) { return other !== app.user.id && social.follows(app.users, other, app.user.id) })\n    app.user.nonfriendFolloweds = app.user.followeds.filter(function (other) { return other !== app.user.id && !social.follows(app.users, other, app.user.id) })\n    app.user.nonfriendFollowers = social.unfollowedFollowers(app.users, app.user.id, app.user.id)\n\n    // refresh suggest options for usernames\n    app.suggestOptions['@'] = []\n    if (app.user.profile) {\n      for (var id in app.users.profiles) {\n        if (id == app.user.profile.id || social.follows(app.users, app.user.id, id)) {\n          var name = app.users.names[id]\n          app.suggestOptions['@'].push({\n            id: id,\n            cls: 'user',        \n            title: name || id,\n            image: pu.getProfilePicUrl(app.users, id),\n            subtitle: name || id,\n            value: name ? ('@'+name) : id\n          })\n        }\n      }\n    }\n\n    app.emit('update:all')\n    cb && cb()\n  })\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/lib/ws-client.js":"var muxrpc     = require('muxrpc')\nvar pull       = require('pull-stream')\nvar ws         = require('pull-ws-server')\nvar Serializer = require('pull-serializer')\nvar t          = require('patchwork-translations')\n\nmodule.exports = function () {\n  // create rpc object\n  var ssb = muxrpc(window.MANIFEST, false, serialize)()\n\n  // setup rpc stream over websockets\n  var protocol = (window.location.protocol == 'https:') ? 'wss:' : 'ws:'\n  var stream = ws.connect(protocol+'//'+(window.location.hostname)+':7777', { onClose: onConnectionLost })\n  pull(stream, ssb.createStream(), stream)\n  return ssb\n}\n\nfunction serialize (stream) {\n  return Serializer(stream, JSON, {split: '\\n\\n'})\n}\n\nfunction onConnectionLost () {\n  var el = document.createElement('div')\n  el.className = 'connection-lost'\n  el.appendChild(document.createTextNode(t('connectionLost')))\n  document.body.insertBefore(el, document.body.firstChild)\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/lib/favicon.js":"const ICON_PATH = '/img/icon.png'\nconst FONT = 'Helvetica, Arial, sans-serif'\nvar canvas = document.createElement('canvas')\nvar img = null\nvar label = false\n\nmodule.exports.update = function (opts) {\n  if ('label' in opts) {\n    if (typeof opts.label == 'number' && opts.label > 0 && opts.label < 10)\n      label = ' '+opts.label\n    else\n      label = opts.label\n  }\n  loadImg(draw)\n}\n\nfunction draw () {\n  var head = document.getElementsByTagName('head')[0]\n  var favicon = document.querySelector('link[rel=icon]')\n  var newFavicon = document.createElement('link')\n  var multiplier, fontSize, context, xOffset, yOffset, border, shadow\n\n  // scale canvas elements based on favicon size\n  multiplier = img.width / 16\n  fontSize   = multiplier * 11\n  xOffset    = multiplier\n  yOffset    = multiplier * 11\n  border     = multiplier\n  shadow     = multiplier * 4\n\n  canvas.height = canvas.width = img.width\n  context = canvas.getContext('2d')\n  context.font = 'bold ' + fontSize + 'px ' + FONT\n\n  // draw favicon background\n  if (label) { context.globalAlpha = 0.8 }\n  context.drawImage(img, 0, 0)\n  context.globalAlpha = 1.0\n\n  if (label) {\n    // draw drop shadow\n    context.shadowColor = '#000'\n    context.shadowBlur = shadow\n    context.shadowOffsetX = 0\n    context.shadowOffsetY = 0\n\n    // draw border\n    // context.fillStyle = '#000'\n    // context.fillText(label, xOffset, yOffset)\n    // context.fillText(label, xOffset + border, yOffset)\n    // context.fillText(label, xOffset, yOffset + border)\n    // context.fillText(label, xOffset + border, yOffset + border)\n\n    // draw label\n    context.fillStyle = '#FFF'\n    context.fillText(label,\n      xOffset + (border / 2.0),\n      yOffset + (border / 2.0)\n    )\n  }\n\n  // replace favicon with new favicon\n  newFavicon.rel = 'icon'\n  newFavicon.href = canvas.toDataURL('image/png')\n  if (favicon) { head.removeChild(favicon) }\n  head.appendChild(newFavicon)\n}\n\nvar loadImgCbs\nfunction loadImg (cb) {\n  // already loaded?\n  if (img)\n    return cb() // go\n\n  // queue active?\n  if (loadImgCbs)\n    return loadImgCbs.push(cb) // add to queue\n\n  // start the queue\n  loadImgCbs = [cb]\n\n  // load image\n  img = document.createElement('img')\n  img.crossOrigin = 'anonymous'\n  img.onload = () => {\n    loadImgCbs.forEach(cb => cb())\n    loadImgCbs = null\n  }\n  img.src = ICON_PATH\n}","/home/travis/build/npmtest/node-npmtest-ssb-patchwork/node_modules/ssb-patchwork/ui/lib/search.js":"'use babel'\nimport React from 'react'\nimport ssbref from 'ssb-ref'\nimport app from './app'\nimport u from 'patchkit-util'\nimport social from 'patchkit-util/social'\nimport t from 'patchwork-translations'\n\nconst MAX_CHANNEL_RESULTS = 3\nconst MAX_USER_RESULTS = 3\n\nexport function getResults (query) {\n  var results = []\n\n  // ssb references\n  if (ssbref.isLink(query)) {\n    var shortened = u.shortString(query)\n    if (ssbref.isFeedId(query))      results = [{ icon: 'user',     label: t('search.OpenUser', {id: shortened}),   fn: openObject }]\n    else if (ssbref.isMsgId(query))  results = [{ icon: 'envelope', label: t('search.OpenMessage', {id: shortened}), fn: openObject }]\n    else if (ssbref.isBlobId(query)) results = [{ icon: 'file',     label: t('search.OpenFile', {id: shortened}),    fn: openObject }]\n    results.push({ icon: 'search', label: t('search.SearchForReferences', {id: shortened}), fn: doSearch({ type: 'mentions' }) })\n    return results\n  }\n\n  // general results\n  results = results.concat([\n    { icon: 'envelope', label: t('search.SearchMessages', {query}), fn: doSearch({ type: 'posts' }) }\n  ])\n\n  // builtin pages\n  // TODO\n\n  // known users\n  results = results.concat(getUserResults(query))\n\n  // channels\n  results = results.concat(getChannelResults(query))\n\n  return results\n}\n\nfunction getUserResults (query) {\n  if (query.charAt(0) == '#') // strip off the pound\n    query = query.slice(1)\n  query = query.toLowerCase()\n\n  var results = []\n  for (let id in app.users.names) {\n    var name = app.users.names[id]\n    if (typeof name == 'string' && name.toLowerCase().indexOf(query) !== -1)\n      results.push(id)\n  }\n  // sort by popularity (isnt that just the way of things?)\n  results.sort(social.sortByPopularity.bind(social, app.users))\n  results = results\n    .slice(0, MAX_USER_RESULTS)\n    .map(id => { return { icon: 'user', label: t('search.OpenUser', {id: app.users.names[id]}), fn: () => openObject(id) } })\n  return results\n}\n\nfunction getChannelResults (query) {\n  if (query.charAt(0) == '#') // strip off the pound\n    query = query.slice(1)\n  query = query.toLowerCase()\n\n  var hasExact = false\n  var results = []\n  for (var i=0; i < app.channels.length && results.length < MAX_CHANNEL_RESULTS; i++) {\n    var ch = app.channels[i]\n    if (ch.name.toLowerCase().indexOf(query) !== -1) {\n      if (!hasExact)\n        hasExact = (ch.name == query)\n      results.push({\n        icon: 'hashtag',\n        label: <span>{t('search.OpenChannel', {name: ch.name})}</span>,\n        fn: openChannel(ch.name)\n      })\n    }\n  }\n  if (!hasExact)\n    results.push({ icon: 'hashtag', label: t('search.OpenChannel', {name: query}), fn: openChannel(query) })\n  return results\n}\n\nfunction openObject (ref) {\n  if (ssbref.isFeedId(ref)) {\n    app.history.pushState(null, '/profile/'+encodeURIComponent(ref))\n  } else if (ssbref.isMsgId(ref)) {\n    app.history.pushState(null, '/msg/'+encodeURIComponent(ref))\n  } else if (ssbref.isBlobId(ref)) {\n    window.location = '/'+encodeURIComponent(ref)\n  }\n}\n\nconst openChannel = channel => () => {\n  if (channel.charAt(0) == '#') // strip off the pound\n    channel = channel.slice(1)\n  app.history.pushState(null, '/channel/'+encodeURIComponent(channel))\n}\n\nexport const doSearch = opts => query => {\n  // TODO incorporate `opts`\n  app.history.pushState(null, '/search/'+encodeURIComponent(query))\n}"}